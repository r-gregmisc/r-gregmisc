{
    "collab_server" : "",
    "contents" : "\\name{heatmap.2}\n\\alias{heatmap.2}\n\\title{ Enhanced Heat Map }\n\\description{\n  A heat map is a false color image (basically\n  \\code{\\link{image}(t(x))}) with a dendrogram added to the left side\n  and/or to the top.  Typically, reordering of the rows and columns\n  according to some set of values (row or column means) within the\n  restrictions imposed by the dendrogram is carried out.\n\n  This heatmap provides a number of extensions to the standard R\n  \\code{\\link[stats]{heatmap}} function.\n}\n\\usage{\nheatmap.2 (x,\n\n           # dendrogram control\n           Rowv = TRUE,\n           Colv=if(symm)\"Rowv\" else TRUE,\n           distfun = dist,\n           hclustfun = hclust,\n           dendrogram = c(\"both\",\"row\",\"column\",\"none\"),\n           reorderfun = function(d, w) reorder(d, w),\n           symm = FALSE,\n\n           # data scaling\n           scale = c(\"none\",\"row\", \"column\"),\n           na.rm=TRUE,\n\n           # image plot\n           revC = identical(Colv, \"Rowv\"),\n           add.expr,\n\n           # mapping data to colors\n           breaks,\n           symbreaks=any(x < 0, na.rm=TRUE) || scale!=\"none\",\n\n           # colors\n           col=\"heat.colors\",\n\n           # block sepration\n           colsep,\n           rowsep,\n           sepcolor=\"white\",\n           sepwidth=c(0.05,0.05),\n\n           # cell labeling\n           cellnote,\n           notecex=1.0,\n           notecol=\"cyan\",\n           na.color=par(\"bg\"),\n\n           # level trace\n           trace=c(\"column\",\"row\",\"both\",\"none\"),\n           tracecol=\"cyan\",\n           hline=median(breaks),\n           vline=median(breaks),\n           linecol=tracecol,\n\n           # Row/Column Labeling\n           margins = c(5, 5),\n           ColSideColors,\n           RowSideColors,\n           cexRow = 0.2 + 1/log10(nr),\n           cexCol = 0.2 + 1/log10(nc),\n           labRow = NULL,\n           labCol = NULL,\n           srtRow = NULL,\n           srtCol = NULL,\n           adjRow = c(0,NA),\n           adjCol = c(NA,0),\n           offsetRow = 0.5,\n           offsetCol = 0.5,\n           colRow = NULL,\n           colCol = NULL,\n\n           # color key + density info\n           key = TRUE,\n           keysize = 1.5,\n           density.info=c(\"histogram\",\"density\",\"none\"),\n           denscol=tracecol,\n           symkey = any(x < 0, na.rm=TRUE) || symbreaks,\n           densadj = 0.25,\n           key.title = NULL,\n           key.xlab = NULL,\n           key.ylab = NULL,\n           key.xtickfun = NULL,\n           key.ytickfun = NULL,\n           key.par=list(),\n\n           # plot labels\n           main = NULL,\n           xlab = NULL,\n           ylab = NULL,\n\n           # plot layout\n           lmat = NULL,\n           lhei = NULL,\n           lwid = NULL,\n\n           # extras\n           extrafun=NULL,\n           ...\n           )\n           }\n\\arguments{\n  % Dendrogram Control\n  \\item{x}{numeric matrix of the values to be plotted. }\n  \\item{Rowv}{determines if and how the \\emph{row} dendrogram should be\n    reordered.\tBy default, it is TRUE, which implies dendrogram is\n    computed and reordered based on row means. If NULL or FALSE, then no\n    dendrogram is computed and no reordering is done. If a\n    \\code{\\link{dendrogram}}, then it is used \"as-is\", ie\n    without any reordering. If a vector of integers, then dendrogram is\n    computed and reordered based on the order of the vector.}\n  \\item{Colv}{determines if and how the \\emph{column} dendrogram should\n    be reordered.\tHas the options as the \\code{Rowv} argument above and\n    \\emph{additionally} when \\code{x} is a square matrix,\n    \\code{Colv=\"Rowv\"} means that columns should be treated identically\n    to the rows.}\n  \\item{distfun}{function used to compute the distance (dissimilarity)\n    between both rows and columns.  Defaults to \\code{\\link{dist}}.}\n  \\item{hclustfun}{function used to compute the hierarchical clustering\n    when \\code{Rowv} or \\code{Colv} are not dendrograms.  Defaults to\n    \\code{\\link{hclust}}.}\n  \\item{dendrogram}{character string indicating whether to draw 'none',\n    'row', 'column' or 'both' dendrograms.  Defaults to 'both'. However,\n    if Rowv (or Colv) is FALSE or NULL and dendrogram is 'both', then a\n    warning is issued and Rowv (or Colv) arguments are honoured.}\n  \\item{reorderfun}{\\code{function(d, w)} of dendrogram and weights for\n    reordering the row and column dendrograms.  The default uses\n    \\code{\\link{stats}{reorder.dendrogram}} }.\n  \\item{symm}{logical indicating if \\code{x} should be treated\n    \\bold{symm}etrically; can only be true when \\code{x} is a\n    square matrix.}\n  % data scaling\n  \\item{scale}{character indicating if the values should be centered and\n    scaled in either the row direction or the column direction, or\n    none.  The default is \\code{\"none\"}.}\n  \\item{na.rm}{logical indicating whether \\code{NA}'s should be removed.}\n  % image plot\n  \\item{revC}{logical indicating if the column order should be\n    \\code{\\link{rev}}ersed for plotting, such that e.g., for the\n    symmetric case, the symmetry axis is as usual.}\n  \\item{add.expr}{expression that will be evaluated after the call to\n    \\code{image}.  Can be used to add components to the plot.}\n  \\item{breaks}{(optional) Either a numeric vector indicating the\n    splitting points for binning \\code{x} into colors, or a integer\n    number of break points to be used, in which case the break points\n    will be spaced equally between \\code{min(x)} and \\code{max(x)}.}\n  \\item{symbreaks}{Boolean indicating whether breaks should be\n    made symmetric about 0. Defaults to \\code{TRUE} if the data includes\n    negative values, and to \\code{FALSE} otherwise.}\n  \\item{col}{colors used for the image. Defaults to heat colors\n    (\\code{heat.colors}).}\n  % block separation\n  \\item{colsep, rowsep, sepcolor}{(optional) vector of integers\n    indicating which columns or rows should be separated from the\n    preceding columns or rows by a narrow space of color\n    \\code{sepcolor}.}\n  \\item{sepwidth}{(optional) Vector of length 2 giving the width\n    (colsep) or height (rowsep) the separator box drawn by colsep and\n    rowsep as a function of the width (colsep) or height (rowsep) of a\n    cell. Defaults to \\code{c(0.05, 0.05)}}\n  % cell labeling\n  \\item{cellnote}{(optional) matrix of character strings which will be\n    placed within each color cell, e.g. p-value symbols.}\n  \\item{notecex}{(optional) numeric scaling factor for \\code{cellnote}\n    items.}\n  \\item{notecol}{(optional) character string specifying the color for\n    \\code{cellnote} text.  Defaults to \"cyan\".}\n  \\item{na.color}{Color to use for missing value (\\code{NA}). Defaults\n    to the plot background color.}\n  % level trace\n  \\item{trace}{character string indicating whether a solid \"trace\" line\n    should be drawn across 'row's or down 'column's, 'both' or 'none'.\n    The distance of the line from the center of each color-cell is\n    proportional to the size of the measurement. Defaults to 'column'.}\n  \\item{tracecol}{character string giving the color for \"trace\"\n    line. Defaults to \"cyan\".}\n  \\item{hline, vline, linecol}{Vector of values within cells where a\n    horizontal or vertical dotted line should be drawn.  The color of\n    the line is controlled by \\code{linecol}.  Horizontal  lines are only\n    plotted if \\code{trace} is 'row' or 'both'.  Vertical lines are only\n    drawn if \\code{trace} 'column' or 'both'.   \\code{hline} and\n    \\code{vline} default to the median of the breaks, \\code{linecol}\n    defaults to the value of \\code{tracecol}.}\n  % Row/Column Labeling\n  \\item{margins}{numeric vector of length 2 containing the margins\n    (see \\code{\\link{par}(mar= *)}) for column and row names,\n    respectively.}\n  \\item{ColSideColors}{(optional) character vector of length\n    \\code{ncol(x)} containing the color names for a horizontal side bar\n    that may be used to annotate the columns of \\code{x}.}\n  \\item{RowSideColors}{(optional) character vector of length\n    \\code{nrow(x)} containing the color names for a vertical side bar\n    that may be used to annotate the rows of \\code{x}.}\n  \\item{cexRow, cexCol}{positive numbers, used as \\code{cex.axis} in\n    for the row or column axis labeling.  The defaults currently only\n    use number of rows or columns, respectively.}\n  \\item{labRow, labCol}{character vectors with row and column labels to\n    use; these default to \\code{rownames(x)} or \\code{colnames(x)},\n    respectively.}\n  \\item{srtRow, srtCol}{angle of row/column labels, in degrees from\n    horizontal}\n  \\item{adjRow, adjCol}{2-element vector giving the (left-right,\n    top-bottom) justification of row/column labels (relative to the text\n    orientation).}\n  \\item{offsetRow, offsetCol}{Number of character-width spaces to\n    place between row/column labels and the edge of the plotting\n    region.}\n  \\item{colRow, colCol}{color of row/column labels, either a scalar to\n    set the color of all labels the same, or a vector providing the\n    colors of each label item}\n  % Color key and density info\n  \\item{key}{logical indicating whether a color-key should be shown.}\n  \\item{keysize}{numeric value indicating the size of the key}\n  \\item{density.info}{character string indicating whether to superimpose\n    a 'histogram', a 'density' plot, or no plot ('none') on the\n    color-key.}\n  \\item{denscol}{character string giving the color for the density\n    display specified by \\code{density.info}, defaults to the same value\n    as \\code{tracecol}.}\n  \\item{symkey}{Boolean indicating whether the color key should be\n    made symmetric about 0. Defaults to \\code{TRUE} if the data includes\n    negative values, and to \\code{FALSE} otherwise.}\n  \\item{densadj}{Numeric scaling value for tuning the kernel width when\n    a density plot is drawn on the color key.  (See the \\code{adjust}\n    parameter for the \\code{density} function for details.)  Defaults to\n    0.25.}\n  \\item{key.title}{main title of the color key. If set to NA no title\n    will be plotted.}\n  \\item{key.xlab}{x axis label of the color key. If set to NA no label\n    will be plotted.}\n  \\item{key.ylab}{y axis label of the color key. If set to NA no label\n    will be plotted.}\n  \\item{key.xtickfun}{function computing tick location and labels for\n    the xaxis of the color key. Returns a named list containing\n    parameters that can be passed to \\code{axis}. See examples.}\n  \\item{key.ytickfun}{function computing tick location and labels for\n    the y axis of the color key. Returns a named list containing\n    parameters that can be passed to \\code{axis}.  See examples.}\n  \\item{key.par}{graphical parameters for the color key. Named list that\n    can be passed to \\code{par}.}\n  % plot labels\n  \\item{main, xlab, ylab}{main, x- and y-axis titles; defaults to none.}\n  % figure layout\n  \\item{lmat, lhei, lwid}{visual layout: position matrix, column height,\n    column width.  See below for details}\n  \\item{extrafun}{A function to be called after all other work. See\n    examples.}\n  \\item{...}{additional arguments passed on to \\code{\\link{image}} }\n}\n\\details{\n  If either \\code{Rowv} or \\code{Colv} are dendrograms they are honored\n  (and not reordered).\tOtherwise, dendrograms are computed as\n  \\code{dd <- as.dendrogram(hclustfun(distfun(X)))} where \\code{X} is\n  either \\code{x} or \\code{t(x)}.\\cr\n\n  If either is a vector (of \\dQuote{weights}) then the appropriate\n  dendrogram is reordered according to the supplied values subject to\n  the constraints imposed by the dendrogram, by \\code{\\link{reorder}(dd,\n    Rowv)}, in the row case.\n  %%\n  If either is missing, as by default, then the ordering of the\n  corresponding dendrogram is by the mean value of the rows/columns,\n  i.e., in the case of rows, \\code{Rowv <- rowMeans(x, na.rm=na.rm)}.\n  %%\n  If either is \\code{\\link{NULL}}, \\emph{no reordering} will be done for\n  the corresponding side.\n\n  If \\code{scale=\"row\"} (or \\code{scale=\"col\"}) the rows (columns) are\n  scaled to have mean zero and standard deviation one.  There is some\n  empirical evidence from genomic plotting that this is useful.\n\n  The default colors range from red to white (\\code{heat.colors}) and\n  are not pretty.  Consider using enhancements such as the\n  \\pkg{RColorBrewer} package,\n  \\url{https://cran.r-project.org/package=RColorBrewer}\n  to select better colors.\n\n  By default four components will be displayed in the plot.  At the top\n  left is the color key, top right is the column dendrogram, bottom left\n  is the row dendrogram, bottom right is the image plot.  When\n  RowSideColor or ColSideColor are provided, an additional row or column\n  is inserted in the appropriate location.   This layout can be\n  overriden by specifiying appropriate values for \\code{lmat},\n  \\code{lwid}, and \\code{lhei}.  \\code{lmat} controls the relative\n  postition of each element, while \\code{lwid} controls the column\n  width, and \\code{lhei} controls the row height. See the help page for\n  \\code{\\link[graphics]{layout}} for details on how to use these\n  arguments.\n}\n\\note{\n  The original rows and columns are reordered to match the dendrograms\n  \\code{Rowv} and \\code{Colv} (if present).\n\n  \\code{heatmap.2()} uses \\code{\\link{layout}} to arragent the plot\n  elements. Consequentially, it can \\bold{not} be used in a multi\n  column/row layout using \\code{\\link{layout}(\\dots)},\n  \\code{\\link{par}(mfrow=\\dots)} or \\code{(mfcol=\\dots)}.\n}\n\\value{\n  Invisibly, a list with components\n  \\item{rowInd}{row index permutation vector as returned by\n    \\code{\\link{order.dendrogram}}.}\n  \\item{colInd}{column index permutation vector.}\n  \\item{call}{the matched call}\n  \\item{rowMeans, rowSDs}{mean and standard deviation of each row: only\n    present if \\code{scale=\"row\"}}\n  \\item{colMeans, colSDs}{mean and standard deviation of each column: only\n    present if \\code{scale=\"column\"}}\n  \\item{carpet}{reordered and scaled 'x' values used generate the main\n    'carpet'}\n  \\item{rowDendrogram}{row dendrogram, if present}\n  \\item{colDendrogram}{column dendrogram, if present}\n  \\item{breaks}{values used for color break points}\n  \\item{col}{colors used}\n  \\item{vline}{center-line value used for column trace, present only if\n    \\code{trace=\"both\"} or \\code{trace=\"column\"} }\n  \\item{hline}{center-line value used for row trace, present only if\n    \\code{trace=\"both\"} or \\code{trace=\"row\"} }\n  \\item{colorTable}{A three-column data frame providing the lower and upper\n    bound and color for each bin}\n  \\item{layout}{A named list containing the values used for\n    \\code{lmat}, \\code{lhei}, and \\code{lwid}. }\n}\n\\author{Andy Liaw, original; R. Gentleman, M. Maechler, W. Huber,\n  G. Warnes, revisions.}\n\n\\seealso{\\code{\\link{image}}, \\code{\\link{hclust}}}\n\n\\examples{\n data(mtcars)\n x  <- as.matrix(mtcars)\n rc <- rainbow(nrow(x), start=0, end=.3)\n cc <- rainbow(ncol(x), start=0, end=.3)\n\n ##\n ## demonstrate the effect of row and column dendrogram options\n ##\n heatmap.2(x)                    ## default - dendrogram plotted and reordering done.\n heatmap.2(x, dendrogram=\"none\") ##  no dendrogram plotted, but reordering done.\n heatmap.2(x, dendrogram=\"row\")  ## row dendrogram plotted and row reordering done.\n heatmap.2(x, dendrogram=\"col\")  ## col dendrogram plotted and col reordering done.\n\n heatmap.2(x, keysize=2)         ## default - dendrogram plotted and reordering done.\n\n heatmap.2(x, Rowv=FALSE, dendrogram=\"both\") ## generates a warning!\n heatmap.2(x, Rowv=NULL, dendrogram=\"both\")  ## generates a warning!\n heatmap.2(x, Colv=FALSE, dendrogram=\"both\") ## generates a warning!\n\n ## Reorder dendrogram by branch means rather than sums\n heatmap.2(x, reorderfun=function(d, w) reorder(d, w, agglo.FUN = mean) )\n\n ## plot a sub-cluster using the same color coding as for the full heatmap\n full <- heatmap.2(x)\n heatmap.2(x, Colv=full$colDendrogram[[2]], breaks=full$breaks)  # column subset\n heatmap.2(x, Rowv=full$rowDendrogram[[1]], breaks=full$breaks)  # row subset\n heatmap.2(x, Colv=full$colDendrogram[[2]],\n              Rowv=full$rowDendrogram[[1]], breaks=full$breaks)  # both\n\n ## Show effect of row and column label rotation\n heatmap.2(x, srtCol=NULL)\n heatmap.2(x, srtCol=0,   adjCol = c(0.5,1) )\n heatmap.2(x, srtCol=45,  adjCol = c(1,1)   )\n heatmap.2(x, srtCol=135, adjCol = c(1,0)   )\n heatmap.2(x, srtCol=180, adjCol = c(0.5,0) )\n heatmap.2(x, srtCol=225, adjCol = c(0,0)   ) ## not very useful\n heatmap.2(x, srtCol=270, adjCol = c(0,0.5) )\n heatmap.2(x, srtCol=315, adjCol = c(0,1)   )\n heatmap.2(x, srtCol=360, adjCol = c(0.5,1) )\n\n heatmap.2(x, srtRow=45, adjRow=c(0, 1) )\n heatmap.2(x, srtRow=45, adjRow=c(0, 1), srtCol=45, adjCol=c(1,1) )\n heatmap.2(x, srtRow=45, adjRow=c(0, 1), srtCol=270, adjCol=c(0,0.5) )\n\n\n ## Show effect of offsetRow/offsetCol (only works when srtRow/srtCol is\n ## not also present)\n heatmap.2(x, offsetRow=0, offsetCol=0)\n heatmap.2(x, offsetRow=1, offsetCol=1)\n heatmap.2(x, offsetRow=2, offsetCol=2)\n heatmap.2(x, offsetRow=-1, offsetCol=-1)\n\n heatmap.2(x, srtRow=0, srtCol=90, offsetRow=0, offsetCol=0)\n heatmap.2(x, srtRow=0, srtCol=90, offsetRow=1, offsetCol=1)\n heatmap.2(x, srtRow=0, srtCol=90, offsetRow=2, offsetCol=2)\n heatmap.2(x, srtRow=0, srtCol=90, offsetRow=-1, offsetCol=-1)\n\n\n ## Show how to use 'extrafun' to replace the 'key' with a scatterplot\n lmat <- rbind( c(5,3,4), c(2,1,4) )\n lhei <- c(1.5, 4)\n lwid <- c(1.5, 4, 0.75)\n\n myplot <- function() {\n             oldpar <- par(\"mar\")\n             par(mar=c(5.1, 4.1, 0.5, 0.5))\n             plot(mpg ~ hp, data=x)\n           }\n\n heatmap.2(x, lmat=lmat, lhei=lhei, lwid=lwid, key=FALSE, extrafun=myplot)\n\n ## show how to customize the color key\n heatmap.2(x,\n           key.title=NA, # no title\n           key.xlab=NA,  # no xlab\n           key.par=list(mgp=c(1.5, 0.5, 0),\n                        mar=c(2.5, 2.5, 1, 0)),\n           key.xtickfun=function() {\n                 breaks <- parent.frame()$breaks\n                 return(list(\n                      at=parent.frame()$scale01(c(breaks[1],\n                                                  breaks[length(breaks)])),\n                      labels=c(as.character(breaks[1]),\n                               as.character(breaks[length(breaks)]))\n                      ))\n           })\n\n heatmap.2(x,\n          breaks=256,\n          key.title=NA,\n          key.xlab=NA,\n          key.par=list(mgp=c(1.5, 0.5, 0),\n                       mar=c(1, 2.5, 1, 0)),\n          key.xtickfun=function() {\n               cex <- par(\"cex\")*par(\"cex.axis\")\n               side <- 1\n               line <- 0\n               col <- par(\"col.axis\")\n               font <- par(\"font.axis\")\n               mtext(\"low\", side=side, at=0, adj=0,\n                     line=line, cex=cex, col=col, font=font)\n               mtext(\"high\", side=side, at=1, adj=1,\n                     line=line, cex=cex, col=col, font=font)\n               return(list(labels=FALSE, tick=FALSE))\n          })\n\n\n ##\n ## Show effect of z-score scaling within columns, blue-red color scale\n ##\n hv <- heatmap.2(x, col=bluered, scale=\"column\", tracecol=\"#303030\")\n\n ###\n ## Look at the return values\n ###\n names(hv)\n\n ## Show the mapping of z-score values to color bins\n hv$colorTable\n\n ## Extract the range associated with white\n hv$colorTable[hv$colorTable[,\"color\"]==\"#FFFFFF\",]\n\n ## Determine the original data values that map to white\n whiteBin <- unlist(hv$colorTable[hv$colorTable[,\"color\"]==\"#FFFFFF\",1:2])\n rbind(whiteBin[1] * hv$colSDs + hv$colMeans,\n       whiteBin[2] * hv$colSDs + hv$colMeans )\n ##\n ## A more decorative heatmap, with z-score scaling along columns\n ##\n hv <- heatmap.2(x, col=cm.colors(255), scale=\"column\",\n\t       RowSideColors=rc, ColSideColors=cc, margin=c(5, 10),\n\t       xlab=\"specification variables\", ylab= \"Car Models\",\n\t       main=\"heatmap(<Mtcars data>, ..., scale=\\\"column\\\")\",\n         tracecol=\"green\", density=\"density\")\n ## Note that the breakpoints are now symmetric about 0\n\n ## Color the labels to match RowSideColors and ColSideColors\n hv <- heatmap.2(x, col=cm.colors(255), scale=\"column\",\n         RowSideColors=rc, ColSideColors=cc, margin=c(5, 10),\n\t       xlab=\"specification variables\", ylab= \"Car Models\",\n\t       main=\"heatmap(<Mtcars data>, ..., scale=\\\"column\\\")\",\n         tracecol=\"green\", density=\"density\", colRow=rc, colCol=cc,\n         srtCol=45, adjCol=c(0.5,1))\n\n\n\n%% want example using the `add.exp' argument!\n\n data(attitude)\n round(Ca <- cor(attitude), 2)\n symnum(Ca) # simple graphic\n\n # with reorder\n heatmap.2(Ca, \t\t symm=TRUE, margin=c(6, 6), trace=\"none\" )\n\n # without reorder\n heatmap.2(Ca, Rowv=FALSE, symm=TRUE, margin=c(6, 6), trace=\"none\" )\n\n ## Place the color key below the image plot\n heatmap.2(x, lmat=rbind( c(0, 3), c(2,1), c(0,4) ), lhei=c(1.5, 4, 2 ) )\n\n ## Place the color key to the top right of the image plot\n heatmap.2(x, lmat=rbind( c(0, 3, 4), c(2,1,0 ) ), lwid=c(1.5, 4, 2 ) )\n\n ## For variable clustering, rather use distance based on cor():\n data(USJudgeRatings)\n symnum( cU <- cor(USJudgeRatings) )\n\n hU <- heatmap.2(cU, Rowv=FALSE, symm=TRUE, col=topo.colors(16),\n              distfun=function(c) as.dist(1 - c), trace=\"none\")\n\n ## The Correlation matrix with same reordering:\n hM <- format(round(cU, 2))\n hM\n\n # now with the correlation matrix on the plot itself\n\n heatmap.2(cU, Rowv=FALSE, symm=TRUE, col=rev(heat.colors(16)),\n             distfun=function(c) as.dist(1 - c), trace=\"none\",\n             cellnote=hM)\n\n ## genechip data examples\n \\dontrun{\n library(affy)\n data(SpikeIn)\n pms <- SpikeIn@pm\n\n # just the data, scaled across rows\n heatmap.2(pms, col=rev(heat.colors(16)), main=\"SpikeIn@pm\",\n              xlab=\"Relative Concentration\", ylab=\"Probeset\",\n              scale=\"row\")\n\n # fold change vs \"12.50\" sample\n data <- pms / pms[, \"12.50\"]\n data <- ifelse(data>1, data, -1/data)\n heatmap.2(data, breaks=16, col=redgreen, tracecol=\"blue\",\n               main=\"SpikeIn@pm Fold Changes\\nrelative to 12.50 sample\",\n               xlab=\"Relative Concentration\", ylab=\"Probeset\")\n }\n\n}\n\\keyword{hplot}\n",
    "created" : 1459177025606.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "457894777",
    "id" : "BD1D11CF",
    "lastKnownWriteTime" : 1459177118,
    "last_content_update" : 1459177118562,
    "path" : "~/src/r-gregmisc/gplots/man/heatmap.2.Rd",
    "project_path" : "man/heatmap.2.Rd",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_doc"
}